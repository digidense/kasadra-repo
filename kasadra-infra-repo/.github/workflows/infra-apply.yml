name: Terraform Apply GKE-Cluster

on:
  pull_request:
    branches:
      - main
    types:
      - closed

jobs:
  terraform:
    if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main' && github.event.pull_request.head.ref == 'development'
    runs-on: ubuntu-latest
    env:
      GOOGLE_CLOUD_KEYFILE_JSON: ${{ secrets.GCP_SA_KEY }}
      PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      CLUSTER_NAME: digi-cluster
      CLUSTER_ZONE: us-central1-c
      USE_GKE_GCLOUD_AUTH_PLUGIN: "True"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      # ---------------------------
      # Authenticate with GCP
      # ---------------------------
      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Set up gcloud CLI (with GKE Auth Plugin)
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}
          install_components: gke-gcloud-auth-plugin

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.5
          
      # - name: Fix script permissions
      #   run: |
      #     sudo apt-get install -y dos2unix
      #     dos2unix deployment.sh
      #     chmod +x deployment.sh
      # ---------------------------
      # Phase 1: Create Cluster + Node Pool
      # ---------------------------
      - name: Terraform Init
        run: terraform init -reconfigure

      - name: Terraform Plan (Cluster + Node Pool)
        run: terraform plan -out=tfplan-cluster

      - name: Terraform Apply (Cluster + Node Pool)
        run: terraform apply -auto-approve tfplan-cluster

      # ---------------------------
      # Get Cluster Credentials
      # ---------------------------
      - name: Get GKE Credentials
        run: |
          gcloud container clusters get-credentials "$CLUSTER_NAME" --zone "$CLUSTER_ZONE" --project "$PROJECT_ID"

      # ---------------------------
      # Deploy Postgres
      # ---------------------------
      - name: Apply Postgres Manifests
        run: |
          kubectl apply -f namespace.yaml
          kubectl apply -f config.yaml
          kubectl apply -f secret.yaml
          kubectl apply -f postgres-pvc.yaml
          kubectl apply -f postgres-deployment.yaml
          kubectl apply -f postgres-service.yaml

      # ---------------------------
      # Deploy Ingress Controller
      # ---------------------------
      - name: Install Ingress Controller
        run: |
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.service.type=LoadBalancer

      # ---------------------------
      # Wait for Ingress LB IP
      # ---------------------------
      - name: Wait for Ingress Controller IP
        run: |
          echo "Waiting for ingress controller LoadBalancer IP..."
          for i in {1..30}; do
            INGRESS_IP=$(kubectl get svc ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$INGRESS_IP" ]; then
              echo "Ingress Controller IP: $INGRESS_IP"
              echo "TF_VAR_ingress_ip=$INGRESS_IP" >> $GITHUB_ENV
              break
            fi
            sleep 10
          done

      # ---------------------------
      # Phase 2: DNS Record
      # ---------------------------
      - name: Terraform Plan (DNS only)
        run: terraform plan -target=google_dns_record_set.frontend_dns -out=tfplan-dns

      - name: Terraform Apply (DNS only)
        run: terraform apply -auto-approve tfplan-dns

      # ---------------------------
      # Show Terraform Outputs
      # ---------------------------
      - name: Show Terraform Outputs
        run: |
          echo "==== Terraform Outputs ===="
          terraform output
